@inherits Fluxor.Blazor.Web.Components.FluxorComponent

@using BlazorStrap
@using Fluxor
@using WebAPP.Store.Cataloging
@using BlazorStrap.V5
@using WebAPP.Abstractions
@using WebAPP.Store.Cataloging.Queries

@inject IState<CatalogingState> State
@inject IDispatcher Dispatcher

@if (State.Value.IsFetching)
{
    <BSSpinner SpinnerType="SpinnerType.Grow" Color="BSColor.Dark" Size="Size.ExtraLarge"/>
}
else if (State.Value.Catalogs.Any())
{
    <div class="row row-cols-md-4">
        @foreach (var catalog in State.Value.Catalogs)
        {
            <BSCol MarginTopAndBottom="Margins.ExtraSmall" Padding="Padding.None">
                <CatalogCard Catalog="catalog"/>
            </BSCol>
        }
    </div>

    <Pagination
        Page="State.Value.Page"
        OnMoveToPage="MoveToPage"
        OnMoveToNext="MoveToNext"
        OnMoveToPrevious="MoveToPrevious"/>
}
else
{
    <p class="text-center">Add your first catalog</p>
}

@code {

    private readonly CancellationTokenSource _cancellationTokenSource = new();

    protected override void OnInitialized()
    {
        base.OnInitialized();
        ListCatalogs();
    }

    private void MoveToPage(int page) => ListCatalogs(offset: page - 1);
    private void MoveToNext() => ListCatalogs(offset: State.Value.Page.Current);
    private void MoveToPrevious() => ListCatalogs(offset: State.Value.Page.Current - 2);

    private void ListCatalogs(int limit = 8, int offset = 0)
        => Dispatcher.Dispatch(new ListCatalogs
        {
            Paging = new(limit, offset),
            CancellationToken = _cancellationTokenSource.Token
        });

    protected override void Dispose(bool disposing)
    {
        if (disposing) _cancellationTokenSource.Dispose();
        base.Dispose(disposing);
    }

}